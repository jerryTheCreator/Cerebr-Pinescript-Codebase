// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Jerry

//@version=4
strategy("Cowabunga Strategy 2.0", overlay=true, pyramiding = 0, default_qty_value=10000)

//General Inputs
//{
res = input("240", "Higher Timeframe", input.resolution)
htferr = input(0, "HTF Convertion Error Buffer")
useMerge = input(true, "Merge Background Coloring? :")
useMeth = input(false, "Use Method 2 Calculation?")
drawPlot = input(false, "Draw Plots on Charts?")

slType = input("Pips", "Stop Loss Calculation", options = ["Levels", "Pips"], group = "Risk Management")
slLen = input(10, "Stop Loss LookBack", group = "Risk Management")
slPip = input(10, "Stop Loss In Pips", group = "Risk Management")
rrr = input(2, "Reward - Risk Ratio", group = "Risk Management")

//Period Converter Function
//{
resToInt(_res) =>
    resInt = 0
    if _res == "D"
        resInt := 1440
    else if _res == "W"
        resInt := 10080
    else if _res == "M"
        resInt := 43200
    else
        resInt := round(tonumber(_res))
    
    resInt

periodConv(_len, _res) =>
    tf = round(tonumber(timeframe.period))
    htf = resToInt(_res)
    
    len = tf < htf ? ((htf * _len) / tf) : na
    
    len
//}

//Functions to Allow Series Length
//{
Sum(src,p) => a = cum(src), a - a[max(p,0)]

Sma(src,p) => a = cum(src), (a - a[max(p,0)])/max(p,0)

Ema(src,p) =>
    ema = 0.
    sf = 2/(p+1)
    ema := nz(ema[1] + sf*(src - ema[1]),src)

Wma(src,p) => 
    mp = max(p,0)
    denom = mp*(mp+1)/2
    a = cum(src), (mp*a - Sum(a[1],p))/denom

Lsma(src,p) => 
    mp = max(p,0)
    denom = mp*(mp+1)/2
    a = cum(src), b = (mp*a - Sum(a[1],p))/denom
    3*b - 2*(a - a[mp])/mp
    
//}

//}----- End of General Input
//FUNCTIONS ==> periodConv(_len, lres, _res)

//*************** CURRENT TIMEFRAME INDICATORS ***************//


//MOVING AVERAGES
//{
maSrc = input(close, "Moving Average Source", input.source, group="MOVING AVERAGE")
maType = input("EMA", "Moving Average Type", options=["SMA", "EMA", "LSMA", "WMA"], group="MOVING AVERAGE")

fLen  = input(5, "Fast Moving Average", input.integer, group="MOVING AVERAGE")
sLen  = input(10, "Slow Moving Average", input.integer, group="MOVING AVERAGE")

calcMA(_len) =>
    ma = maType == "SMA" ? Sma(maSrc, _len) : 
      (maType == "EMA" ? Ema(maSrc, _len) : 
      (maType == "LSMA" ? Lsma(maSrc, _len) : 
      (maType == "WMA" ? Wma(maSrc, _len) : na)))
    ma
    
fastMa = calcMA(fLen)
slowMa = calcMA(sLen)

maLong = crossover(fastMa, slowMa)
maShort = crossunder(fastMa, slowMa)

//}----- End of Moving Averages
//SIGNALS ==> maLong, maShort

//STOCHASTIC 
//{
periodK = input(10, title="Stoch Length", minval=1, group="STOCHASTIC")
smoothK = input(3, title="Stochastic Line", minval=1, group="STOCHASTIC")
periodD = input(3, title="Stoch Signal Line", minval=1, group="STOCHASTIC")
stOB    = input(80, title="Stoch Overbought", minval=50, group="STOCHASTIC")
stOS    = input(20, title="Stoch OverSold", minval=1, group="STOCHASTIC")


stoch  = sma(stoch(close, high, low, periodK), smoothK)
stSma = sma(stoch, periodD)

stLong = stoch > stSma
stShort = stoch < stSma
stOBought = stoch >= stOB
stOSold = stoch <= stOS

//}-----End of Stocastics
//SIGNALS ==> stLong, stShort, stOBought, stOSold

//RSI
//{
rsiSrc = input(close, "RSI Source", input.source, group="RSI")
rsiLen  = input(9, "RSI Period", input.integer, group="RSI")

rsi = rsi(rsiSrc, rsiLen)

rsiLong = rsi > 50
rsiShort = rsi < 50

//}----- End of RSI
//SIGNALS ==> rsiLong, rsiShort

//MACD
//{

macdSrc = input(close, "MACD Source", input.source, group="MACD")
macdfLen = input(12, "Fast MACD", input.integer, group="MACD")
macdsLen = input(21, "Slow MACD", input.integer, group="MACD")
macdSig = input(9, "MACD Signal Line", input.integer, group="MACD")

[macd, signal, hist] = macd(macdSrc, macdfLen, macdsLen, macdSig)

decHistGreen = hist > 0 and hist[1] > hist
decHistRed = hist > 0 and hist[1] < hist

macdGoesBear = crossunder(hist, 0)
macdGoesBull = crossover(hist, 0)

//}
//SIGNALS ==> decHistGreen, decHistRed, macdGoesBear, macdGoesBull


//*************** HIGHER TIMEFRAME INDICATORS ***************//


//HTF MOVING AVERAGES
//{

htfFLen = periodConv(fLen, res)
htfSLen = periodConv(sLen, res)

htffastMa = useMeth ? calcMA(htfFLen) : security(syminfo.tickerid, res, fastMa, barmerge.gaps_on, barmerge.lookahead_off)
htfslowMa = useMeth ? calcMA(htfSLen) : security(syminfo.tickerid, res, slowMa, barmerge.gaps_on, barmerge.lookahead_off)

htfmaLong = htffastMa > htfslowMa
htfmaShort = htffastMa < htfslowMa

//}----- End of Moving Averages
//SIGNAL ==> htfmaLong, htfmaShort

//HTF STOCHASTIC 
//{

htfperiodK = periodConv(periodK, res)  + htferr
htfsmoothK = periodConv(smoothK, res)
htfperiodD = periodConv(periodD, res)

htfstoch  = useMeth ? sma(stoch(close, high, low, htfperiodK), htfsmoothK) : 
  security(syminfo.tickerid, res, stoch, barmerge.gaps_on, barmerge.lookahead_off)
  
htfstSma = useMeth ? sma(htfstoch, htfperiodD) : sma(htfstoch, periodD)

htfstLong = htfstoch > htfstSma
htfstShort = htfstoch < htfstSma
htfstOBought = htfstoch >= stOB
htfstOSold = htfstoch <= stOS

//}-----End of HTF Stocastics
//SIGNALS ==> htfstLong, htfstShort, htfstOBought, htfstOSold

//HTF RSI
//{

htfrsi = security(syminfo.tickerid, res, rsi, barmerge.gaps_off, barmerge.lookahead_off)

htfrsiLong = htfrsi > 50
htfrsiShort = htfrsi < 50

//}----- End of RSI
//SIGNALS ==> htfrsiLong, htfrsiShort


//STRATEGY LOGIC

//HTF LOGIC
//{

htfgoLong = htfmaLong and htfrsiLong and htfstLong and (htfstOBought == false)
htfgoShort = htfmaShort and htfrsiShort and htfstShort and (htfstOSold == false)

htfLong = barssince(htfgoLong) < barssince(htfgoShort)
htfShort = barssince(htfgoLong) > barssince(htfgoShort)

//}----- End of HTF Logic
//SIGNALS ==> htfLong, htfShort

//MAIN LOGIC
//{
goLong = htfLong and maLong and stLong and (stOBought == false) and (decHistRed or macdGoesBull)
  
goShort = htfShort and maShort and stShort and (stOSold == false) and (decHistGreen or macdGoesBear)

//}-----End of Main Logic
//SIGNAL = goLong, goShort

//Stop Loss
//{
pip() => syminfo.mintick * (syminfo.type == "forex" ? 10 : 1)

hi = highest(slLen)
lo = lowest(slLen)

sl = slType == "Levels" ? (htfLong ? lo : 
  (htfShort ? hi : na)) : 
  (slType == "Pips" ? (htfLong ? close[1] - (slPip * pip()) : (htfShort ? close[1] + (slPip * pip()) : na)) : na)

risk = abs(close[1] - sl)
tp = htfLong ? close[1] + (rrr * risk) : htfShort ? close[1] - (rrr * risk) : na
//}----- End of Risk Management
//Returns ==> sl, tp

//ENTRIES AND EXITS
//{
if (goLong)
    strategy.entry("Buy", strategy.long)

if (goShort)
    strategy.entry("Sell", strategy.short)
    
strategy.exit("Exit Long", "Buy", limit = tp, stop = sl)
strategy.exit("Exit Short", "Sell", limit = tp, stop = sl)
//}


//PLOTS
//{

bgcolor(drawPlot == false ? na : useMerge ? htfLong ? color.new(color.olive, 90) : htfShort ? color.new(color.red, 90) : na : 
  htfgoLong ? color.new(color.olive, 90) : htfgoShort ? color.new(color.red, 90) : na)

plotshape(drawPlot == false ? na : goLong, "Long", shape.triangleup, location.belowbar, color.lime, size = size.small)
plotshape(drawPlot == false ? na : goShort, "Short", shape.triangledown, location.abovebar, color.maroon, size = size.small)
plot(drawPlot == false ? na : sl, style = plot.style_linebr, color = color.red) //Possible SL Levels
plot(drawPlot == false ? na : tp, style = plot.style_linebr, color = color.olive) //Possible SL Levels
//}

