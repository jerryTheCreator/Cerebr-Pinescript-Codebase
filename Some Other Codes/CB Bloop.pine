//@version=4
study("Cerebr Bloop", "CB Bloop", false, format.price, 2)

// GENERAL FUNCTIONS
// [
tf(_res, _exp, gaps_on)  => gaps_on == 0 ? security(syminfo.tickerid, _res, _exp) :
  gaps_on == true ? security(syminfo.tickerid, _res, _exp, barmerge.gaps_on, barmerge.lookahead_off ) : 
  security(syminfo.tickerid, _res, _exp, barmerge.gaps_off, barmerge.lookahead_off )
  
updateArr(arr, upd) =>
    len = array.size(arr)
    
    for i = 0 to len - 2
        array.set(arr, i, array.get(arr, i + 1))
        array.set(arr, len - 1, upd)
// ]


//>>>>>>>>>> HEIKEN ASHI <<<<<<<<<<//
// [
// TOOLTIPS
// [
string TT_HARSI = "Period for the RSI calculations used to generate the"        +
                  "candles. This seperate from the RSI plot/histogram length."

string TT_PBIAS = "Smoothing feature for the OPEN of the HARSI candles."        +
                  "\n\nIncreases bias toward the prior open value which can"    +
                  " help provide better visualisation of trend strength."       +
                  "\n\n** By changing the Open values, High and Low can also"   +
                  " be distorted - however Close will remain unchanged."

string TT_SMRSI = "This option smoothes the RSI in a manner similar to HA"      +
                  " open, but uses the realtime rsi rather than the prior"      +
                  " close value."

string TT_STOCH = "Uses the RSI generated by the above settings, and as such"   +
                  " will be affected by the smoothing option."

string TT_STFIT = "Adjusts the vertical scaling of the stochastic, can help"    +
                  " to prevent distortion of other data in the channel."        +
                  "\n\nHas no impact cross conditions."
// ]


// INPUTS AND PARAMETERS
// [
// -- Heiken Ashi config
i_smoothing = input( 7, "HA Smoothing", input.integer, group = "Heiken Ashi", minval = 1, maxval = 100, tooltip = TT_PBIAS )

// -- RSI plot config
i_source    = input( ohlc4, "Source", input.source, group = "RSI" )
i_lenRSI    = input( 7, "Length", input.integer, group = "RSI", minval = 1 )
i_mode      = input( true, "Smoothed Mode RSI?", input.bool, group = "RSI", tooltip = TT_SMRSI )
i_showPlot  = true, i_showHist  = false 

// -- Channel OB/OS config
i_upper     = input( 20, "HA OB", input.integer,  group = "OB/OS Boundaries", inline = "OB", minval = 1, maxval = 50 )
i_upperx    = input( 30, "OB Extreme", input.integer,  group = "OB/OS Boundaries", inline = "OB", minval = 1, maxval = 50 )
i_lower     = input( -20, "HA OS", input.integer,  group = "OB/OS Boundaries", inline = "OS", minval = -50, maxval = -1 )
i_lowerx    = input( -30, "OS Extreme", input.integer,  group = "OB/OS Boundaries", inline = "OS", minval = -50, maxval = -1 )

// -- Parameters 
i_lenHARSI  = 14
i_colUp     = color.teal, i_colDown   = color.red, i_colWick   = color.gray
// ]


// FUNCTIONS
// [

f_zrsi( _source, _length ) => rsi( _source, _length ) - 50


f_rsi( _source, _length, _mode ) =>
    float _zrsi = f_zrsi( _source, _length )
    var float _smoothed = na
    _smoothed := na( _smoothed[1] ) ? _zrsi : ( _smoothed[1] + _zrsi ) / 2
    _mode ? _smoothed : _zrsi


f_rsiHeikinAshi( _length ) =>

    float _closeRSI = f_zrsi( close, _length )
    float _openRSI  = nz( _closeRSI[1], _closeRSI )
    float _highRSI_raw  = f_zrsi( high, _length )
    float _lowRSI_raw   = f_zrsi( low, _length )
    float _highRSI  = max( _highRSI_raw, _lowRSI_raw )
    float _lowRSI   = min( _highRSI_raw, _lowRSI_raw )
    float _close    = ( _openRSI + _highRSI + _lowRSI + _closeRSI ) / 4
    var float _open = na
    _open  := na( _open[ i_smoothing ] ) ? ( _openRSI + _closeRSI ) / 2 :
              ( ( _open[1] * i_smoothing ) + _close[1] ) / ( i_smoothing + 1 )
    float _high     = max( _highRSI, max( _open, _close ) )
    float _low      = min( _lowRSI,  min( _open, _close ) )
    [ _open, _high, _low, _close ]

// ]


// CALCULATIONS
// [
//  standard, or ha smoothed rsi for the line plot and/or histogram
float RSI = f_rsi( i_source, i_lenRSI, i_mode )

//  get OHLC values to use in the plotcandle()
[ O, H, L, C ] = f_rsiHeikinAshi( i_lenHARSI )

//  candle body colouring
color bodyColour = C > O ? i_colUp : i_colDown, color wickColour = i_colWick

//  shadow, invisible
color colShadow = color.rgb( 0, 0, 0, 20 ), color colNone = color.rgb( 0, 0, 0, 100 )

//  rsi color
color colRSI = color.rgb( 250, 200, 50, 0 )
// ]


// PLOTS
// [
//  zero median RSI channel hlines
upperx  = hline( i_upperx,  "OB Extreme",   color.new( color.silver, 60 ) )
upper   = hline( i_upper,   "OB",           color.new( color.silver, 80 ) )
median  = hline( 0,         "Median",       color.orange, hline.style_dotted )
lower   = hline( i_lower,   "OS",           color.new( color.silver, 80 ) )
lowerx  = hline( i_lowerx,  "OS Extreme",   color.new( color.silver, 60 ) )

//  channel fill
fill( upper, upperx, color.new( color.red, 90 ),    title = "Background Fill OB" )
fill( upper, lower,  color.new( color.blue, 90 ),   title = "Background Channel" )
fill( lower, lowerx, color.new( color.green, 90 ),  title = "Background Fill OS" )

//  histogram first, so it is on the bottom of the plot/candle draw stack
plot( i_showHist ? RSI : na,    "RSI Histogram",    color.new( color.silver, 80 ),  1, plot.style_histogram )

//  make our HA rsi candles
plotcandle( O, H, L, C, "HARSI", bodyColour, wickColour, bordercolor = bodyColour )

//  RSI overlay plot
plot( i_showPlot ? RSI : na,                    "RSI Shadow",       colShadow,  3 )
plot_rsi    = plot( i_showPlot ? RSI : na,      "RSI Overlay",      colRSI,     1 )
// ]
// ]


//>>>>>>>>>> HTF RSI <<<<<<<<<<//
// [
// INPUTS 
rsiTf = input("", "HTF RSI Timeframe", input.resolution, group="HTF RSI")
tfRsiOb = input(70, "RSI Overbought", input.float, minval=50, group="HTF RSI")
tfRsiOs = input(30, "RSI Oversold", input.float, maxval=50, group="HTF RSI")

// CALCULATIONS
tfRsi = tf(rsiTf, rsi(close, 14), 0)
// ]


//>>>>>>>>>> MOVING AVERAGE <<<<<<<<<<//
// [
// INPUTS
maTf = input("", "Moving Average Timeframe", input.resolution, group="Moving Average")
maLen = input(50, "Moving Average Length", input.integer, minval=1, group="Moving Average")

// CALCULATIONS
ma = tf(maTf, ema(close, maLen), 0)
// ]


// ALL CONDITIONS
// [
useRsiFilt = input(true, "Use RSI to Filter Entries?", input.bool, group="Entry Conditions")
useMaFilt = input(false, "Use Moving Avearage to Filter Entries?", input.bool, group="Entry Conditions")
useHaCloseFilt = input(true, "Apply Candle Close Rule?", input.bool, group="Entry Conditions")
haObosMeth = input("High/Low", "HA Candle Buffer For Overbought/Oversold", options=["High/Low", "Candle Body"], group="Entry Conditions")
maLback = input(10, "Moving Average Lookback", input.integer, minval=1, tooltip="For Determination of Trend Direction", group="Entry Conditions")

// Heiken Ashi
// {
c_harsiOb = RSI >= i_upper, c_harsiOs = RSI <= i_lower // HA-RSI Ob/Os

c_haOb = haObosMeth == "High/Low" ? H >= i_upper : max(O, C) >= i_upper // HA CANDLE Overbought
c_haOs = haObosMeth == "High/Low" ? L <= i_lower : min(O, C) <= i_lower // HA CANDLE Oversold
c_upHa = C > O, c_dnHa = O > C

c_haValidClose = C > i_lower and C < i_upper // CLOSE WITHIN SAFE ZONE

c_NewUpHA = c_upHa and not c_upHa[1] , c_NewDnHA = c_dnHa and not c_dnHa[1]
// }

// HTF Rsi  
c_tfRsiOb = tfRsi >= tfRsiOb    ,   c_tfRsiOs = tfRsi <= tfRsiOs

// Moving Average
c_maLong = tf(maTf, rising(ma, maLback), 0)     ,   c_maShort = tf(maTf, falling(ma, maLback), 0)
c_xmaLong = close > ma  ,   c_xmaShort = close < ma

// Condition-Filter Application
rsiLong = useRsiFilt ? c_tfRsiOs : true     ,    rsiShort = useRsiFilt ? c_tfRsiOb : true
maLong = useMaFilt ? c_maLong : true        ,    maShort = useMaFilt ? c_maShort : true

haLongTrigger = useHaCloseFilt ? C > O and c_haValidClose and not(c_haValidClose[1]) : c_NewUpHA
haShortTrigger = useHaCloseFilt ? C < O and c_haValidClose and not(c_haValidClose[1]) : c_NewDnHA
// ]


// ENTRY SCREENING
// [
var pendingLong = false, var pendingShort = false
var goLong = false, var goShort = false

// METHOD 1 ENTRY
condLong1 = c_dnHa and c_haOs and rsiLong and maLong   ,   condShort1 = c_upHa and c_haOb and rsiShort and maShort

// METHOD 2 ENTRY
condLong2 = c_maLong and c_xmaLong and c_harsiOs and tfRsi < 50    ,   condShort2 = c_maShort and c_xmaShort and c_harsiOb and tfRsi > 50

// ENTRY EXECUTION
if condLong1
    pendingLong := true
if condShort1
    pendingShort := true

goLong := pendingLong and haLongTrigger ? true : false  ,   goShort := pendingShort and haShortTrigger ? true : false

if goLong
    pendingLong := false
if goShort
    pendingShort := false

// ]


// TRAILING STOP ALGORITHM
// [
f_progress(_init_ent, _init_sl, _curr) =>
    progress = 0.0
    
    if _init_ent > _init_sl // Long
        slDist = _init_ent - _init_sl
        currDist = _curr - _init_ent
        
        progress := currDist / slDist
    
    if _init_sl > _init_ent // Short
        slDist = _init_sl - _init_ent 
        currDist = _init_ent - _curr
        
        progress := round(currDist / slDist, 1)
    
    progress

f_valTrigger(_prog) => (_prog >= 1) and ((_prog * 10) % 5) == 0

f_getSL(_init_ent, _init_sl, _prog, _inc) =>
    newSl = 0.0
    newRR = _prog - _inc // eg progress = 2, Lock-Milestone = 0.5 GETS THE MILESTONE FOR THE PROGRESS
    
    if _init_ent > _init_sl // Long
        slDist = _init_ent - _init_sl
        newSl := _init_ent + (newRR * slDist)
    
    if _init_sl > _init_ent // Short
        slDist = _init_sl - _init_ent 
        newSl := _init_ent - (newRR * slDist)

    newSl
    
trail(_init_ent, _init_sl, _currPrice, _currSl, _trailInc) =>
    _trail = false
    sl = _currSl
    
    // Get the Progress of a Trade, From Initial Entry and Stop Loss Prices
    progress = f_progress(_init_ent, _init_sl, _currPrice)
    
    // Find Valid Trailing SL Triggers
    valTrigger = f_valTrigger(progress)
    
    // If Valid Trigger is Found, Check If The New Stop Loss is Higher (for Longs) or Lower (for Shorts) than the Current Stop Loss
    if valTrigger
        
        // Long: If new stop loss is higher than current, increase the stop loss. Else: Don't move stop loss
        if _init_ent > _init_sl // Long
            newSl = f_getSL(_init_ent, _init_sl, progress, _trailInc)
            
            if newSl > _currSl
                sl := newSl // Successful Trailing
                _trail := true
                // #### Code to Move Stop Loss
        
        // Short: If new stop loss is lower than current, decrease the stop loss. Else: Don't move stop loss
        if _init_sl > _init_ent // Short
            newSl = f_getSL(_init_ent, _init_sl, progress, _trailInc)
            
            if newSl < _currSl
                sl := newSl // Successful Trailing
                _trail := true
                // #### Code to Move Stop Loss
    
    //### Alternative Code to Return Trail SL Signal and Price
    [_trail, sl]
// ]


// SL Code{
slLback = input(10, "Lookback for SL Finding", input.integer)
slAtr = atr(14)

possBearSl = highest(slLback), possBullSl = lowest(slLback)
// }